#The aglorism in sched-adv.cpp is created by myself.


There are  2 problem with multiple queue priority scheduler. The first one is  low priority entity starvation. If there are too many entities with priority of REALTIME, the entities with priority of INTERACTIVE or NORMAL or DAEMON will almost never be scheduled because only the entity with the highest priority will be scheduled each time. This problem is due to priority. The second problem is low time utilization. The entities of the same priority will only be scheduled in a round-robin fashion. If the entities with many cpu execution time are scheduled before entities with few cpu execution time, the average waiting time will be long and hence, time utilization is low. 

To solve the first and second problem, I use the expression (priority level * cpu execution time) to determine which next entity should be picked. Assume there are 4 priority level which is (1(REALTIME),2(INTERACTIVE),3(NORMAL),4(DAEMON)). The entity with the lowest value of expression (priority level * cpu execution time) will be picked each time. This means the low priority entity with few cpu execution time will not suffer from starvation and also time ultilization will be better because both priority and cpu execution time are taken into account. Another advantage is that aglorism running time is small because aglorism is simple. However, there is 1 disadvantage with my aglorism. That is the low priority entity with many cpu execution still in starvation. My aglorism combines both the pros of Multiple QueuePriority Scheduler and Completely Fair Scheduler. Hence, my aglorism is better than both Completely Fair Scheduler and Multiple QueuePriority Scheduler although it is not perfect.
